# C++

## Антон Полухин | Незаменимый С++ | VK video, 2022

https://vkvideo.ru/video-77278886_456239374

Поисковые движки. Браузеры.

Высоконагруженные сервисы.

Игровые движки.
Спецэффекты и анимация для фильмов. C++11
Компиляторы.
Программы исследовательских лабораторий.
ОС, драйверы
Автопром.
Embedded.
Заводы.
Сопромат.
Биржа.
JVM

6:45 Zero Overhead. Поддержаа большого числа платформ.

9:45 Assembler: + максимум из железа, - оч. медленная разработка, - непереносимый код, - не всегда быстрее

11:00 Пример: целочисленное деление. Сравнение в Compiler Explorer. На assembler реализуется сложно. Компилятор C++ за десятки лет стал знать гигантское число низкоуровневых оптимизаций, над которыми думали множество групп людей. Выучить их, держать в голове и не путаться asm-разработчику невозможно.

13:00 Rust: лет через 15 больше возможностей для оптимизации, frontend компилятора больше знает о том, как алиасятся различные типы.

17:45 Из C можно легко перейти на C++. В Rust нужно оборачивать в unsafe. Нет хорошего генератора Rust-объявлений из C headers. Нужно допиливать руками и мучаться с borrow checker.

21:00 Даже если у языка крутой компилятор и подключены статические анализаторы, всё равно нужно писать тесты. Unsafe

22:45 Golang. Лучшая поддержка асинхронности и многопоточности из коробки - корутины.

Альтернативы для многопоточности на C++: Boost.Fibers, Yandex.Taxi userver, Quantum, Folly Fibers, Coroutines TS, C++20. Go скорее конкурент Python, чем C++.

24:30 Обманные бенчмарки: отключается сборщик мусора. Выделяется такой кусок памяти, что сборщик не запускается во время бенчмарка. Соломенное чучело: непрофессиональный код C++, с идиомами языка, привычного составителю бенча (например, аллокация float в цикле). C++ из коробки не оч. хорош с регулярными выражениями.

29:45 Простейший сборщик мусора - mark & sweep. Хранит ссылки на структуры данных, обходит их и помечает используемое. Непомеченное удаляет. Двусвязный список? Как собирать мусор? Stop the world (останавливаем все потоки, чтобы race condition не происходили).

34:30 Сборщик мусора no stop the world: ничего не останавливает. Накладные расходы на синхронизацию, обычно через атомарные инструкции. Нужно хранить доп. данные в структуре. Чем больше и сложнее структура, тем сложнее железу оптимизировать работу с ней. Иногда оптимизируют сборщик, чтобы он не проверял всё каждый раз, а обычно делал легковесные обходы, но оставляет за собой мусор. Идеальный сборщик мусора, не оставляющий мусор => нужно испльзовать shared_ptr. C++ разработчики знают, насколько он медленный. Но двусвязный список на shared_ptr это чиклические ссылки, их нужно тоже как-то обнаруживать и удалять. Баланс между скоростью работы (использованием CPU) и качеством сборки мусора (использованием оперативы). Большинство gc настраиваемые.

39:00 C# / Java лучше C++ для приложений, где не нужно быстро обрабатывать большие данные. Logstash на Java - считывает логи, бьёт на ключи и отправляет. Но ест процессора в 8 раз больше приложения, которое эти логи порождает. И в 2 раза больше оперативной памяти. Аналог, написанный на C++ в топе использования ресурсов даже не показывается.

41:20 C++ - высокий порог вхождения. Проблемы с безопасностью. Крошечная стандартная библиотека. Инфраструктуру нужно настраивать под себя. Go/Python/Rust позволяют создать стартап за день.

43:00 Итоги.

49:00 Вопрос: идея написать корпоративный фреймворк, позволяющий быстро разрабатывать приложения на C++.

https://github.com/apolukhin

## Libs

- [fmt](https://github.com/fmtlib/fmt) by [fmtlib](https://github.com/fmtlib)
	- _A modern formatting library_
- [awesome-cpp](https://github.com/fffaraz/awesome-cpp) by [fffaraz](https://github.com/fffaraz)
	- _A curated list of awesome C++ (or C) frameworks, libraries, resources, and shiny things. Inspired by awesome-... stuff._